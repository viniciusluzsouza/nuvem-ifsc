-- -------------------------------------------------------------
--
-- Module: P1_tb
-- Path: hdl_prj/hdlsrc/simulink_with_hdl
-- Created: 2019-07-03 13:50:08
-- Generated by MATLAB 8.5 and HDL Coder 3.6
-- Hierarchy Level: 1
--
--
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.numeric_std.ALL;
USE STD.textio.ALL;
USE IEEE.std_logic_textio.ALL;

USE work.P1_tb_pkg.ALL;

USE work.P1_tb_data.ALL;

ENTITY P1_tb IS

END P1_tb;


ARCHITECTURE rtl OF P1_tb IS
  -- -------------------------------------------------------------
  -- Component Declarations
  -- -------------------------------------------------------------
  COMPONENT P1
   PORT( clk                             :   IN    std_logic; 
         resetx                          :   IN    std_logic; 
         clkenable                       :   IN    std_logic; 
         ceout                           :   OUT   std_logic; 
         Out_P1_1                        :   OUT   std_logic_vector(33 DOWNTO 0); -- sfix34_En28
         Out_P1_2                        :   OUT   std_logic_vector(33 DOWNTO 0)  -- sfix34_En28
         );
  END COMPONENT;

  -- -------------------------------------------------------------
  -- Component Configuration Statements
  -- -------------------------------------------------------------
  FOR ALL : P1
    USE ENTITY work.P1(rtl);

  -- Constants
  CONSTANT clk_high                         : time := 5 ns;
  CONSTANT clk_low                          : time := 5 ns;
  CONSTANT clk_period                       : time := 10 ns;
  CONSTANT clk_hold                         : time := 2 ns;
  CONSTANT MAX_ERROR_COUNT                : integer := 101; -- uint32


  -- Signals
  SIGNAL clk                              : std_logic; -- boolean
  SIGNAL resetx                           : std_logic; -- boolean
  SIGNAL clkenable                        : std_logic; -- boolean
  SIGNAL ceout                            : std_logic; -- boolean
  SIGNAL Out_P1_1                         : std_logic_vector(33 DOWNTO 0); -- sfix34_En28
  SIGNAL Out_P1_2                         : std_logic_vector(33 DOWNTO 0); -- sfix34_En28

  SIGNAL tb_enb                           : std_logic; -- boolean
  SIGNAL srcDone                          : std_logic; -- boolean
  SIGNAL snkDone                          : std_logic; -- boolean
  SIGNAL testFailure                      : std_logic; -- boolean
  SIGNAL tbenb_dly                        : std_logic; -- boolean
  SIGNAL Out_P1_1_testFailure             : std_logic; -- boolean
  SIGNAL Out_P1_1_errCnt                  : integer; -- uint32
  SIGNAL Out_P1_1_rdenb                   : std_logic; -- boolean
  SIGNAL Out_P1_1_addr                    : unsigned(6 DOWNTO 0); -- ufix7
  SIGNAL Out_P1_1_done                    : std_logic; -- boolean
  SIGNAL Out_P1_1_ref                     : std_logic_vector(33 DOWNTO 0); -- sfix34_En28
  SIGNAL check1_Done                      : std_logic; -- boolean
  SIGNAL Out_P1_2_testFailure             : std_logic; -- boolean
  SIGNAL Out_P1_2_errCnt                  : integer; -- uint32
  SIGNAL Out_P1_2_rdenb                   : std_logic; -- boolean
  SIGNAL Out_P1_2_addr                    : unsigned(6 DOWNTO 0); -- ufix7
  SIGNAL Out_P1_2_done                    : std_logic; -- boolean
  SIGNAL Out_P1_2_ref                     : std_logic_vector(33 DOWNTO 0); -- sfix34_En28
  SIGNAL check2_Done                      : std_logic; -- boolean


BEGIN
  -- Component Instances
  u_P1: P1
    PORT MAP (
              clk                              => clk,
              resetx                           => resetx,
              clkenable                        => clkenable,
              ceout                            => ceout,
              Out_P1_1                         => Out_P1_1,
              Out_P1_2                         => Out_P1_2      );


  -- Block Statements
  -- -------------------------------------------------------------
  -- Driving the test bench enable
  -- -------------------------------------------------------------

  tb_enb <= '0' WHEN resetx = '1' ELSE 
            '1' WHEN snkDone = '0' ELSE 
            '0' AFTER clk_period * 2;

  completed_msg: PROCESS (clk, resetx)
  BEGIN
    IF (resetx = '1') THEN 
       -- Nothing to reset here.
    ELSIF clk'event AND clk = '1' THEN
      IF snkDone='1' THEN
        IF (testFailure = '0') THEN
              ASSERT FALSE
                REPORT "**************TEST COMPLETED (PASSED)**************"
                SEVERITY NOTE;
        ELSE
              ASSERT FALSE
                REPORT "**************TEST COMPLETED (FAILED)**************"
                SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

  -- -------------------------------------------------------------
  -- System Clock (fast clock) and reset
  -- -------------------------------------------------------------

  clk_gen: PROCESS
  BEGIN
    clk <= '1';
    WAIT FOR clk_high;
    clk <= '0';
    WAIT FOR clk_low;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR clk_high;
      clk <= '0';
      WAIT FOR clk_low;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  resetx_gen: PROCESS
  BEGIN
    resetx <= '1';
    WAIT FOR clk_period * 2;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR clk_hold;
    resetx <= '0';
    WAIT;
  END PROCESS resetx_gen;

  -- -------------------------------------------------------------
  -- Testbench clock enable
  -- -------------------------------------------------------------

  tb_enb_delay : PROCESS (clk, resetx)
  BEGIN
    IF resetx = '1' THEN
      tbenb_dly <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF tb_enb = '1' THEN
        tbenb_dly <= tb_enb;
      END IF;
    END IF; 
  END PROCESS tb_enb_delay;

  -- -------------------------------------------------------------
  --  Checker: Checking the data received from the DUT.
  -- -------------------------------------------------------------

  Out_P1_1_procedure (
    clk       => clk,
    reset     => resetx,
    rdenb     => Out_P1_1_rdenb,
    addr      => Out_P1_1_addr,
    done      => Out_P1_1_done);

  Out_P1_1_rdenb <= ceout;

  checker_1: PROCESS(clk, resetx)
  FILE fp_Out_P1_1 :TEXT OPEN READ_MODE IS "Out_P1_1.dat";
  VARIABLE line_Out_P1_1 :line;
  VARIABLE Out_P1_1_expected :std_logic_vector(33 DOWNTO 0);
  VARIABLE data_Out_P1_1_1 :std_logic_vector(35 DOWNTO 0);
  BEGIN
    IF resetx = '1' THEN
      Out_P1_1_errCnt <= 0;
      Out_P1_1_testFailure <= '0';
    ELSIF clk'event and clk ='1' THEN
      IF Out_P1_1_rdenb = '1' THEN
      IF  not (ENDFILE(fp_Out_P1_1)) THEN
            readline(fp_Out_P1_1,line_Out_P1_1);
            hread(line_Out_P1_1,data_Out_P1_1_1);
       END IF;
      Out_P1_1_expected := (SLICE(to_bitvector(data_Out_P1_1_1),34));
      Out_P1_1_ref <= Out_P1_1_expected;
        IF Out_P1_1 /= Out_P1_1_expected THEN
          Out_P1_1_errCnt <= Out_P1_1_errCnt + 1;
          Out_P1_1_testFailure <= '1';
          ASSERT FALSE 
            REPORT "Error in Out_P1_1: Expected " 
            & to_hex(Out_P1_1_expected)
            & " Actual "
            & to_hex(Out_P1_1)
            SEVERITY ERROR;
          IF Out_P1_1_errCnt >= MAX_ERROR_COUNT THEN
            ASSERT FALSE
              REPORT "Number of errors have exceeded the maximum error"
              SEVERITY Warning;
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS checker_1;

  checkDone_1: PROCESS(clk, resetx)
  BEGIN
    IF resetx = '1' THEN
      check1_Done <= '0';
    ELSIF clk'event and clk ='1' THEN
      IF check1_Done = '0' AND Out_P1_1_done = '1' AND Out_P1_1_rdenb = '1' THEN
        check1_Done <= '1';
      END IF;
    END IF;
  END PROCESS checkDone_1;
  -- -------------------------------------------------------------
  --  Checker: Checking the data received from the DUT.
  -- -------------------------------------------------------------

  Out_P1_2_procedure (
    clk       => clk,
    reset     => resetx,
    rdenb     => Out_P1_2_rdenb,
    addr      => Out_P1_2_addr,
    done      => Out_P1_2_done);

  Out_P1_2_rdenb <= ceout;

  checker_2: PROCESS(clk, resetx)
  FILE fp_Out_P1_2 :TEXT OPEN READ_MODE IS "Out_P1_2.dat";
  VARIABLE line_Out_P1_2 :line;
  VARIABLE Out_P1_2_expected :std_logic_vector(33 DOWNTO 0);
  VARIABLE data_Out_P1_2_1 :std_logic_vector(35 DOWNTO 0);
  BEGIN
    IF resetx = '1' THEN
      Out_P1_2_errCnt <= 0;
      Out_P1_2_testFailure <= '0';
    ELSIF clk'event and clk ='1' THEN
      IF Out_P1_2_rdenb = '1' THEN
      IF  not (ENDFILE(fp_Out_P1_2)) THEN
            readline(fp_Out_P1_2,line_Out_P1_2);
            hread(line_Out_P1_2,data_Out_P1_2_1);
       END IF;
      Out_P1_2_expected := (SLICE(to_bitvector(data_Out_P1_2_1),34));
      Out_P1_2_ref <= Out_P1_2_expected;
        IF Out_P1_2 /= Out_P1_2_expected THEN
          Out_P1_2_errCnt <= Out_P1_2_errCnt + 1;
          Out_P1_2_testFailure <= '1';
          ASSERT FALSE 
            REPORT "Error in Out_P1_2: Expected " 
            & to_hex(Out_P1_2_expected)
            & " Actual "
            & to_hex(Out_P1_2)
            SEVERITY ERROR;
          IF Out_P1_2_errCnt >= MAX_ERROR_COUNT THEN
            ASSERT FALSE
              REPORT "Number of errors have exceeded the maximum error"
              SEVERITY Warning;
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS checker_2;

  checkDone_2: PROCESS(clk, resetx)
  BEGIN
    IF resetx = '1' THEN
      check2_Done <= '0';
    ELSIF clk'event and clk ='1' THEN
      IF check2_Done = '0' AND Out_P1_2_done = '1' AND Out_P1_2_rdenb = '1' THEN
        check2_Done <= '1';
      END IF;
    END IF;
  END PROCESS checkDone_2;
  -- -------------------------------------------------------------
  -- Create done and test failure signal for output data
  -- -------------------------------------------------------------

  snkDone <= check1_Done AND check2_Done;

  testFailure <= Out_P1_1_testFailure OR Out_P1_2_testFailure;

  -- -------------------------------------------------------------
  -- Global clock enable
  -- -------------------------------------------------------------
  clkenable <= tbenb_dly AFTER clk_hold WHEN snkDone = '0' ELSE
                '0' AFTER clk_hold;

  -- Assignment Statements



END rtl;
